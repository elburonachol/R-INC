<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Comunicar con R y RStudio</title>
    <meta charset="utf-8" />
    <meta name="author" content="Instituto Nacional de Epidemiología" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="animate.min.css" type="text/css" />
    <link rel="stylesheet" href="fonts_mtheme.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Comunicar con R y RStudio
]
.author[
### Instituto Nacional de Epidemiología
]
.date[
### 27-11-2023
]

---


layout: true
class: animated, fadeIn






&lt;style type="text/css"&gt;
.code {
  color: #777;
  width: 48%;
  height: 92%;
  float: left;
}
.plot {
  width: 50%;
  height: 70%;
  float: right;
  padding-left: 1%;
}
&lt;/style&gt;

---
class: left
background-image: url(assets/esquema_comunicar.PNG)
background-size: 850px
background-position: 50% 60%

## Comunicar como parte del proceso del análisis

---
class: left
background-image: url(assets/Captura2.PNG)
background-size: 700px
background-position: 50% 60%

## Productos de RStudio

---
## Programación literaria o literal (Literate Programming)

.font150[
- La idea original proviene de Don Knuth

- Un artículo es un flujo de texto y código

- El código del análisis se divide en texto y porciones de código “chunks”

- El código de la presentación da formato a los resultados (tablas, figuras, etc)

- El texto del artículo explica lo que está sucediendo en el análisis

- Los programas literarios se tejen para producir documentos legibles 

En definitiva, la programación literaria mezcla:

- Un lenguaje de documentación
- Un lenguaje de programación
]

---
background-image: url(assets/Captura5.PNG) 
background-size: 750px
background-position: 50% 50%

## Flujo de trabajo
---

class: left

## Markdown

.font150[
**Markdown** es un lenguaje de marcas ligero que trata de conseguir la máxima legibilidad y “publicabilidad” .

Se ubica en el grupo de los lenguajes de marcas como HTML, XML, entre otros, aunque es mucho más sencillo de utilizar.

Viene soportado por RStudio, tanto para sus Notebooks como para documentos R Makdown y presentaciones (slides)

Luego se conecta con el convertidor de documentos universal Pandoc (http://pandoc.org/) para transformarse en formatos html (web), pdf o Word. 
]

---
background-image: url(assets/Captura6.PNG) 
background-size: 400px
background-position: 80% 50%

## YAML

.code[.font140[
RStudio incorpora un encabezado construido en **lenguaje YAML** en los archivos R Markdown para indicarle a Pandoc que tipo de documento queremos construir.

Un encabezado YAML es un conjunto de pares clave:valor al comienzo del archivo. Siempre comienza y termina con tres rayas (- - -)

YAML es la sigla de **“yet another markup language”** y es un lenguaje de estructuración de datos sencillo.

]]

---
background-image: url(assets/Captura7.PNG) 
background-size: 600px
background-position: 50% 80%

## knitr

.font150[
**knitr** es una herramienta para la generación de informes dinámico en R (integrada en Rstudio). 

Es un paquete de R (disponible en CRAN) que permite integrar código y sus salidas en documentos **Latex** y **HTML**, entre otros formatos conocidos.

El propósito de knitr es dar espacio a la reproducibilidad de investigación en R a través de Programación Literaria (código, salida y documentación en la misma salida)

]

---

## Elementos que se pueden integrar

.font150[
- Lenguaje hmtl o latex (dependiendo la salida final)
- Tablas con estilos diferentes  (https://www.tablesgenerator.com) 
- Figuras importadas (archivos jpg o png)
- Formatos con estilos predefinidos (mediante plantillas – paquetes como rticules por ejemplo.)
- Citas bibliográficas
- Índices (marcadores para PDF’s)

Resultados de fragmentos de código R

- Resultados entre líneas de texto
- Tablas 
- Resúmenes de modelos estadísticos
- Gráficos y mapas estáticos
- Gráficos y mapas interactivos (en formato Html)


]

---

## Quarto

.font140[
*Quarto* unifica la funcionalidad de muchos paquetes del *ecosistema R Markdown* (rmarkdown, bookdown, distill, xaringan, etc.) en un único sistema y lo amplía con soporte nativo para múltiples lenguajes de programación como Python y Julia, además de R.

- el software se descarga de [quarto.org](https://quarto.org/)

- los archivos *Quarto* son archivos de texto plano con extensión **.qmd**

- el funcionamiento es similar al R markdown, con cabeceras YAML y renderizado por knitr.

]

---
## Diferencias entre Quarto y rmarkdown

.font150[
- R Markdown requiere de R. Quarto es independiente.

- El ecosistema de paquetes R se reemplaza por un marco de trabajo único al que se puede acceder desde otros lenguajes.
]
---
## Qué se puede hacer con Quarto que no se pueda con R Markdown?

.font140[
Aunque utilizar ambos formatos son similares, con **Quarto** se puede:

- Organizar más fácilmente la apariencia de todos los documentos 

- Elementos como por ejemplo, figuras y tablas son más compatibles con varios formatos. 

- Mejores referencias cruzadas (artículos científicos)

- Diapositivas revealjs actualizadas 

- Es más fácil personalizar sitios web y libros con proyectos.
]
---
## Estructura de un documento

.font140[
Un documento contiene *contenido*, *estructura*, *apariencia* y *formato*.

- **Contenido**: texto, código, gráficos. 

- **Estructura**: párrafos, listas, énfasis, etc. 

- **Apariencia**: fuentes, colores, diseño. 

- **Formato**: funcionalidad (estático, interactivo, diapositivas, etc)
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
.logo {
  background-image: url(logo_INE.PNG);
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top: 1em;
  right: 1em;
  width: 55px;
  height: 64px;
  z-index: 0;
}
</style>

<script>
document
  .querySelectorAll(
    '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
    // ':not(.inverse)' +
    ':not(.hide-logo)'
  )
  .forEach(el => {
    el.innerHTML += '<div class="logo"></div>';
  });
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
